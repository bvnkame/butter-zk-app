import assert from 'assert';
// import { Performance } from '../../../lib/testing/perf-regression.js';
import { Provable } from 'o1js';
import { Bytes32, Ecdsa, EcdsaVerify, Secp256k1, ecdsa, ecdsaEthers, keccakAndEcdsa, secp256k1Verify, secp256r1programNoEndo } from './ecdsa.js';
import { initialAggregator, Point } from 'node_modules/o1js/dist/node/lib/provable/gadgets/elliptic-curve.js';
import { Field3, Gadgets } from 'node_modules/o1js/dist/node/lib/provable/gadgets/gadgets.js';

// create an example ecdsa signature

// let privateKey = Secp256k1.Scalar.random();
// let publicKey = Secp256k1.generator.scale(privateKey);

// let message = Bytes32.fromString("what's up");

// let signature = Ecdsa.sign(message.toBytes(), privateKey.toBigInt());

// investigate the constraint system generated by ECDSA verify

// console.time('ecdsa analyzeMethods only (build constraint system)');
// let csEcdsa = await ecdsa.analyzeMethods();
// console.timeEnd('ecdsa analyzeMethods only (build constraint system)');
// console.log(csEcdsa.verifySignedHash.summary());

// console.time('KeccakAndEcdsa analyzeMethods (build constraint system)');
// let cs = await keccakAndEcdsa.analyzeMethods();
// console.timeEnd('KeccakAndEcdsa analyzeMethods (build constraint system)');
// console.log(cs.verifyEcdsa.summary());

// compile and prove

// const perfKeccakEcdsa = Performance.create(keccakAndEcdsa.name, cs);
// perfKeccakEcdsa.start('compile');
// await keccakAndEcdsa.compile();
// // perfKeccakEcdsa.end();

// // perfKeccakEcdsa.start('prove', 'verifyEcdsa');
// console.time('Verify Ecdsa time => ');
// let { proof } = await keccakAndEcdsa.verifyEcdsa(message, signature, publicKey);
// // perfKeccakEcdsa.end();
// console.timeEnd('Verify Ecdsa time => ');

// proof.publicOutput.assertTrue('signature verification failed!');

// // perfKeccakEcdsa.start('verify', 'verifyEcdsa');
// console.time('KeccakAndEcdsa verify proof time => ');
// const isValid = await keccakAndEcdsa.verify(proof);
// console.timeEnd('KeccakAndEcdsa verify proof time => ');
// // perfKeccakEcdsa.end();

// assert(isValid, 'proof verification failed!');

// // Hardcoded ethers.js signature and inputs for verification in o1js

// // message signed using ethers.js
// const msg = 'Secrets hidden, truth in ZKPs ;)';

// // uncompressed public key generated by ethers.js
// // const uncompressedPublicKey =
// //   '0x040957928494c38660d254dc03ba78f091a4aea0270afb447f193c4daf6648f02b720071af9b5bda4936998ec186e632f4be82886914851d7c753747b0a949d1a4';

// // compressed public key generated by ethers.js
// let compressedPublicKey =
//   '0x02579728494c38660d254dc03ba78f091a4aea0270afb447f193c4daf6648f02b';
// // let compressedPublicKey = Point.from({
// //     x: 49781623198970027997721070672560275063607048368575198229673025608762959476014n,
// //     y: 44999051047832679156664607491606359183507784636787036192076848057884504239143n,
// // });
// let signatureE = Ecdsa.fromHex('0x82de9950cc5aac0dca7210cb4b77320ac9e844717d39b1781e9d941d920a12061da497b3c134f50b2fce514d66e20c5e43f9615f097395a5527041d14860a52f1b');

// const publicKeyE = Secp256k1.fromEthers(compressedPublicKey);
// // const signatureE = Ecdsa.fromHex(rawSignature);
// const msgBytes = Bytes32.fromString(msg);

// // investigate the constraint system generated by ECDSA verifyEthers
// console.time('ethers analyzeMethods only (build constraint system)');
// let csEcdsaEthers = await ecdsaEthers.analyzeMethods();
// console.timeEnd('ethers analyzeMethods only (build constraint system)');
// console.log(csEcdsaEthers.verifyEthers.summary());

// // compile and prove
// // const perfEcdsaEthers = Performance.create(ecdsaEthers.name, csEcdsaEthers);
// // perfEcdsaEthers.start('compile');
// await ecdsaEthers.compile();
// // perfEcdsaEthers.end();

// // perfEcdsaEthers.start('prove', 'verifyEthers');
// console.time('Verify Ethers time => ');
// let { proof: proofE } = await ecdsaEthers.verifyEthers(msgBytes, signatureE, publicKeyE);
// // perfEcdsaEthers.end();

// proofE.publicOutput.assertTrue('signature verification failed!');
// console.timeEnd('Verify Ethers time => ');

// console.time('Verifying Ethers proof time => ');
// const isValidE = await ecdsaEthers.verify(proofE);
// console.timeEnd('Verifying Ethers proof time => ');
// // perfEcdsaEthers.end();

// assert(isValidE, 'proof verification failed!');

// --- Now test secp256r1 curve ECDSA verification ---
// const Secp256k1CurveAffine = createCurveAffine(Crypto.CurveParams.Secp256k1);

// const k1msgHash = Gadgets.Field3.from(0x3e91cd8bd233b3df4e4762b329e2922381da770df1b31276ec77d0557be7fcefn);

// const k1PublicKey = Point.from({
//     x: 49781623198970027997721070672560275063607048368575198229673025608762959476014n,
//     y: 44999051047832679156664607491606359183507784636787036192076848057884504239143n,
// });

// const k1Signature = EcdsaVerify.Signature.fromHex('0x82de9950cc5aac0dca7210cb4b77320ac9e844717d39b1781e9d941d920a12061da497b3c134f50b2fce514d66e20c5e43f9615f097395a5527041d14860a52f1b');

// console.time('secp256k1');
// let csEcdsa = await secp256k1Verify.analyzeMethods();
// console.timeEnd('secp256k1');

// console.log(csEcdsa.verifySecp256k1.summary());

// await secp256k1Verify.compile();

// console.time('secp256k1 Generate proof time => ');
// let { proof: proofK1 } = await secp256k1Verify.verifySecp256k1(k1msgHash, k1Signature, k1PublicKey);
// console.timeEnd('secp256k1 Generate proof time => ');

// proofK1.publicOutput.assertTrue('secp256k1 signature verification failed!');

// console.time('secp256k1 Verify proof time => ');
// const isValidK1 = await secp256k1Verify.verify(proofK1);
// console.timeEnd('secp256k1 Verify proof time => ');

// assert(isValidK1, 'secp256k1 proof verification failed!');





console.log('-----------------------------------');

let r1PublicKey = Point.from({
    x: 49781623198970027997721070672560275063607048368575198229673025608762959476014n,
    y: 44999051047832679156664607491606359183507784636787036192076848057884504239143n,
});
let r1Signature = EcdsaVerify.Signature.fromHex('0x82de9950cc5aac0dca7210cb4b77320ac9e844717d39b1781e9d941d920a12061da497b3c134f50b2fce514d66e20c5e43f9615f097395a5527041d14860a52f1b');
let r1MsgHash = Field3.from(0x3e91cd8bd233b3df4e4762b329e2922381da770df1b31276ec77d0557be7fcefn);

console.time('ecdsa verify (constant)');
secp256r1programNoEndo.rawMethods.ecdsa(r1MsgHash, r1Signature, r1PublicKey)
console.timeEnd('ecdsa verify (constant)');

// await Provable.runAndCheck(secp256r1programNoEndo.rawMethods.ecdsa);

console.time('secp256r1 no endo');
let csEcdsaNoEndo = await secp256r1programNoEndo.analyzeMethods();
console.timeEnd('secp256r1 no endo');

console.log(csEcdsaNoEndo.ecdsa.summary());

await secp256r1programNoEndo.compile();

console.time('secp256r1 no endo Generate proof time => ');
let { proof: proofR1NoEndo } = await secp256r1programNoEndo.ecdsa(r1MsgHash, r1Signature, r1PublicKey);
console.timeEnd('secp256r1 no endo Generate proof time => ');

proofR1NoEndo.publicOutput.assertTrue('secp256r1 no endo signature verification failed!');

console.time('secp256r1 no endo Verify proof time => ');
const isValidR1NoEndo = await secp256r1programNoEndo.verify(proofR1NoEndo);
console.timeEnd('secp256r1 no endo Verify proof time => ');

assert(isValidR1NoEndo, 'secp256r1 no endo proof verification failed!');

console.log('All ECDSA proofs verified successfully!');